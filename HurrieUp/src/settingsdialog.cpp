#include "settingsdialog.h"
#include "soundinfodialog.h"
#include "ui_settingsdialog.h" // This will be generated by Qt's UIC
#include <QDir>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QDebug>
#include <QTimer>
#include <QUrl>
#include <QLabel>
#include <QVBoxLayout>
#include <QGraphicsOpacityEffect>
#include <QRandomGenerator>
#include <QFileDialog>
#include <QInputDialog>
#include <QMessageBox>
#include <QStandardPaths>
#include <QFile>
#include <QPushButton>
#include <QSettings>
#include <QHBoxLayout>

SettingsDialog::SettingsDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::SettingsDialog)
{
    ui->setupUi(this);
    
    connect(ui->completeRadioButton, &QRadioButton::toggled, this, &SettingsDialog::onModeChanged);
    connect(ui->combinationRadioButton, &QRadioButton::toggled, this, &SettingsDialog::onModeChanged);
    connect(ui->previewButton, &QPushButton::clicked, this, &SettingsDialog::onPreviewClicked);
    
    connect(ui->addRingButton, &QPushButton::clicked, this, &SettingsDialog::onAddRingClicked);
    connect(ui->addVoiceButton, &QPushButton::clicked, this, &SettingsDialog::onAddVoiceClicked);
    connect(ui->addCompleteButton, &QPushButton::clicked, this, &SettingsDialog::onAddCompleteClicked);
    
    // Initialize preview players
    previewPlayer1 = new QMediaPlayer(this);
    previewAudioOutput1 = new QAudioOutput(this);
    previewPlayer1->setAudioOutput(previewAudioOutput1);
    
    previewPlayer2 = new QMediaPlayer(this);
    previewAudioOutput2 = new QAudioOutput(this);
    previewPlayer2->setAudioOutput(previewAudioOutput2);
    
    loadUserSounds();
    updateUIForMode();
}

SettingsDialog::~SettingsDialog()
{
    stopPreview();
    delete ui;
}

void SettingsDialog::setInterval(int minutes)
{
    ui->intervalSpinBox->setValue(minutes);
}

int SettingsDialog::interval() const
{
    return ui->intervalSpinBox->value();
}

void SettingsDialog::setVolume(int volume)
{
    ui->volumeSlider->setValue(volume);
}

int SettingsDialog::volume() const
{
    return ui->volumeSlider->value();
}

void SettingsDialog::setSoundGap(int ms)
{
    ui->soundGapSpinBox->setValue(ms);
}

int SettingsDialog::soundGap() const
{
    return ui->soundGapSpinBox->value();
}

void SettingsDialog::setRingPaths(const QStringList &paths)
{
    for (QCheckBox *cb : ringCheckboxes) {
        cb->setChecked(paths.contains(cb->property("soundPath").toString()));
    }
}

QStringList SettingsDialog::ringPaths() const
{
    QStringList result;
    for (QCheckBox *cb : ringCheckboxes) {
        if (cb->isChecked()) {
            result.append(cb->property("soundPath").toString());
        }
    }
    return result;
}

void SettingsDialog::setVoicePaths(const QStringList &paths)
{
    for (QCheckBox *cb : voiceCheckboxes) {
        cb->setChecked(paths.contains(cb->property("soundPath").toString()));
    }
}

QStringList SettingsDialog::voicePaths() const
{
    QStringList result;
    for (QCheckBox *cb : voiceCheckboxes) {
        if (cb->isChecked()) {
            result.append(cb->property("soundPath").toString());
        }
    }
    return result;
}

void SettingsDialog::setCompletePaths(const QStringList &paths)
{
    for (QCheckBox *cb : completeCheckboxes) {
        cb->setChecked(paths.contains(cb->property("soundPath").toString()));
    }
}

QStringList SettingsDialog::completePaths() const
{
    QStringList result;
    for (QCheckBox *cb : completeCheckboxes) {
        if (cb->isChecked()) {
            result.append(cb->property("soundPath").toString());
        }
    }
    return result;
}

void SettingsDialog::setIsCompleteMode(bool isComplete)
{
    ui->completeRadioButton->setChecked(isComplete);
    ui->combinationRadioButton->setChecked(!isComplete);
    updateUIForMode();
}

bool SettingsDialog::isCompleteMode() const
{
    return ui->completeRadioButton->isChecked();
}

void SettingsDialog::onModeChanged()
{
    updateUIForMode();
}

void SettingsDialog::updateUIForMode()
{
    bool isComplete = ui->completeRadioButton->isChecked();
    
    // Show/hide complete mode widgets
    ui->labelComplete->setVisible(isComplete);
    ui->completeScrollArea->setVisible(isComplete);
    
    // Show/hide combination mode widgets
    ui->label_3->setVisible(!isComplete);
    ui->ringScrollArea->setVisible(!isComplete);
    ui->label_4->setVisible(!isComplete);
    ui->voiceScrollArea->setVisible(!isComplete);
    ui->label_5->setVisible(!isComplete);
    ui->soundGapSpinBox->setVisible(!isComplete);
}

void SettingsDialog::createSoundCheckboxList(QVBoxLayout *layout, const QList<SoundInfo> &sounds, QList<QCheckBox*> &checkboxes)
{
    // Clear existing checkboxes
    while (layout->count() > 0) {
        QLayoutItem *item = layout->takeAt(0);
        if (item->widget()) {
            delete item->widget();
        }
        delete item;
    }
    checkboxes.clear();

    // Create checkbox for each sound
    for (const SoundInfo &sound : sounds) {
        QWidget *itemWidget = new QWidget();
        QHBoxLayout *mainLayout = new QHBoxLayout(itemWidget);
        mainLayout->setContentsMargins(5, 5, 5, 5);
        mainLayout->setSpacing(5);

        // Left side: checkbox and labels
        QWidget *leftWidget = new QWidget();
        QVBoxLayout *itemLayout = new QVBoxLayout(leftWidget);
        itemLayout->setContentsMargins(0, 0, 0, 0);
        itemLayout->setSpacing(2);

        QCheckBox *checkbox = new QCheckBox(sound.name);
        checkbox->setProperty("soundPath", sound.path);
        checkboxes.append(checkbox);

        // Add visual distinction for user sounds
        if (!sound.isBundled) {
            QFont boldFont = checkbox->font();
            boldFont.setBold(true);
            checkbox->setFont(boldFont);
            checkbox->setStyleSheet("QCheckBox { color: #0066cc; }");
        }

        QLabel *descLabel = new QLabel(sound.description);
        descLabel->setWordWrap(true);
        descLabel->setStyleSheet("color: palette(text);");
        QFont font = descLabel->font();
        font.setPointSize(font.pointSize() - 1);
        descLabel->setFont(font);
        
        // Apply opacity effect
        QGraphicsOpacityEffect *opacityEffect = new QGraphicsOpacityEffect(descLabel);
        opacityEffect->setOpacity(0.6);
        descLabel->setGraphicsEffect(opacityEffect);

        itemLayout->addWidget(checkbox);
        itemLayout->addWidget(descLabel);

        mainLayout->addWidget(leftWidget, 1);

        // Right side: preview button
        QPushButton *previewBtn = new QPushButton("â–¶");
        previewBtn->setMaximumWidth(30);
        previewBtn->setToolTip(tr("Preview this sound"));
        previewBtn->setProperty("soundPath", sound.path);
        connect(previewBtn, &QPushButton::clicked, this, [this, sound]() {
            stopPreview();
            int vol = ui->volumeSlider->value();
            previewAudioOutput1->setVolume(vol / 100.0);
            qDebug() << "Preview sound:" << sound.path;
            previewPlayer1->setSource(QUrl(sound.path));
            previewPlayer1->play();
        });
        mainLayout->addWidget(previewBtn);

        // Right side: info button
        QPushButton *infoBtn = new QPushButton("â„¹");
        infoBtn->setMaximumWidth(30);
        infoBtn->setToolTip(tr("Show info about this sound"));
        infoBtn->setProperty("soundPath", sound.path);
        connect(infoBtn, &QPushButton::clicked, this, [this, sound]() {
            showSoundInfo(sound);
        });
        mainLayout->addWidget(infoBtn);

        // Right side: delete button (only for user sounds)
        if (!sound.isBundled) {
            QPushButton *deleteBtn = new QPushButton("ðŸ—‘");
            deleteBtn->setMaximumWidth(30);
            deleteBtn->setToolTip(tr("Remove this sound"));
            deleteBtn->setProperty("soundPath", sound.path);
            
            connect(deleteBtn, &QPushButton::clicked, this, [this, sound, layout, &checkboxes]() {
                auto reply = QMessageBox::question(
                    this,
                    tr("Confirm Delete"),
                    tr("Are you sure you want to remove '%1'?").arg(sound.name),
                    QMessageBox::Yes | QMessageBox::No);
                
                if (reply == QMessageBox::Yes) {
                    // Remove from appropriate list
                    userRings.removeAll(sound);
                    userVoices.removeAll(sound);
                    userCompletes.removeAll(sound);
                    
                    // Delete file
                    QFile::remove(sound.path);
                    
                    saveUserSounds();
                    refreshSoundLists();
                }
            });
            
            mainLayout->addWidget(deleteBtn);
        }

        layout->addWidget(itemWidget);
    }
    
    layout->addStretch();
}

void SettingsDialog::populateSoundLists(const QList<SoundInfo> &rings, const QList<SoundInfo> &voices, const QList<SoundInfo> &completes)
{
    ringList = rings;
    voiceList = voices;
    completeList = completes;

    refreshSoundLists();

    qDebug() << "Populated sound lists - Bundled Rings:" << rings.size() 
             << "Voices:" << voices.size() 
             << "Completes:" << completes.size();
}

void SettingsDialog::onPreviewClicked()
{
    stopPreview();
    
    // Get current volume
    int vol = ui->volumeSlider->value();
    previewAudioOutput1->setVolume(vol / 100.0);
    previewAudioOutput2->setVolume(vol / 100.0);
    
    if (ui->completeRadioButton->isChecked()) {
        // Complete mode - play random selected sound
        QStringList selectedPaths = completePaths();
        if (!selectedPaths.isEmpty()) {
            int randomIndex = QRandomGenerator::global()->bounded(selectedPaths.size());
            QString completeSoundPath = selectedPaths[randomIndex];
            qDebug() << "Preview complete sound:" << completeSoundPath;
            previewPlayer1->setSource(QUrl(completeSoundPath));
            previewPlayer1->play();
        } else {
            qDebug() << "No complete sound selected";
        }
    } else {
        // Combination mode - play random ring then random voice
        QStringList selectedRings = ringPaths();
        QStringList selectedVoices = voicePaths();
        
        if (!selectedRings.isEmpty() && !selectedVoices.isEmpty()) {
            int ringIndex = QRandomGenerator::global()->bounded(selectedRings.size());
            int voiceIndex = QRandomGenerator::global()->bounded(selectedVoices.size());
            
            QString ringSoundPath = selectedRings[ringIndex];
            QString voiceSoundPath = selectedVoices[voiceIndex];
            int gap = ui->soundGapSpinBox->value();
            
            qDebug() << "Preview ring sound:" << ringSoundPath;
            previewPlayer1->setSource(QUrl(ringSoundPath));
            previewPlayer1->play();
            
            // Play voice after gap
            QTimer::singleShot(gap, this, [this, voiceSoundPath](){
                qDebug() << "Preview voice sound:" << voiceSoundPath;
                previewPlayer2->setSource(QUrl(voiceSoundPath));
                previewPlayer2->play();
            });
        } else {
            qDebug() << "No ring or voice sound selected";
        }
    }
}

void SettingsDialog::stopPreview()
{
    if (previewPlayer1->playbackState() == QMediaPlayer::PlayingState) {
        previewPlayer1->stop();
    }
    if (previewPlayer2->playbackState() == QMediaPlayer::PlayingState) {
        previewPlayer2->stop();
    }
}

QString SettingsDialog::copyToUserSoundsFolder(const QString &sourcePath, const QString &category)
{
    // Get app data directory
    QString appDataPath = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    QString userSoundsDir = appDataPath + "/user_sounds/" + category;
    
    // Create directory if it doesn't exist
    QDir dir;
    if (!dir.exists(userSoundsDir)) {
        dir.mkpath(userSoundsDir);
    }
    
    // Generate unique filename
    QFileInfo fileInfo(sourcePath);
    QString fileName = fileInfo.fileName();
    QString destPath = userSoundsDir + "/" + fileName;
    
    // If file already exists, add number suffix
    int counter = 1;
    while (QFile::exists(destPath)) {
        QString baseName = fileInfo.completeBaseName();
        QString extension = fileInfo.suffix();
        destPath = userSoundsDir + "/" + baseName + "_" + QString::number(counter) + "." + extension;
        counter++;
    }
    
    // Copy file
    if (QFile::copy(sourcePath, destPath)) {
        qDebug() << "Copied sound file to:" << destPath;
        return destPath;
    } else {
        qWarning() << "Failed to copy sound file:" << sourcePath << "to" << destPath;
        return QString();
    }
}

void SettingsDialog::addUserSound(const QString &category)
{
    // Open file dialog
    QString file = QFileDialog::getOpenFileName(
        this, 
        tr("Select Sound File"), 
        QStandardPaths::writableLocation(QStandardPaths::MusicLocation),
        tr("Audio Files (*.wav *.mp3 *.ogg *.flac *.m4a);;All Files (*.*)"));
    
    if (file.isEmpty()) {
        return;
    }
    
    // Get name from user
    bool ok;
    QString name = QInputDialog::getText(
        this, 
        tr("Sound Name"), 
        tr("Enter a name for this sound:"),
        QLineEdit::Normal,
        QFileInfo(file).completeBaseName(),
        &ok);
    
    if (!ok || name.isEmpty()) {
        return;
    }
    
    // Get description from user
    QString description = QInputDialog::getText(
        this, 
        tr("Sound Description"), 
        tr("Enter a description (optional):"),
        QLineEdit::Normal,
        tr("Custom sound"),
        &ok);
    
    if (!ok) {
        description = tr("Custom sound");
    }
    
    // Copy file to user sounds folder
    QString destPath = copyToUserSoundsFolder(file, category);
    if (destPath.isEmpty()) {
        QMessageBox::warning(this, tr("Error"), tr("Failed to copy sound file."));
        return;
    }
    
    // Add to appropriate list
    SoundInfo newSound;
    newSound.name = name;
    newSound.description = description;
    newSound.path = destPath;
    newSound.isBundled = false;
    
    if (category == "ring") {
        userRings.append(newSound);
    } else if (category == "voice") {
        userVoices.append(newSound);
    } else if (category == "complete") {
        userCompletes.append(newSound);
    }
    
    saveUserSounds();
    refreshSoundLists();
    
    QMessageBox::information(this, tr("Success"), tr("Sound added successfully!"));
}

void SettingsDialog::onAddRingClicked()
{
    addUserSound("ring");
}

void SettingsDialog::onAddVoiceClicked()
{
    addUserSound("voice");
}

void SettingsDialog::onAddCompleteClicked()
{
    addUserSound("complete");
}

void SettingsDialog::refreshSoundLists()
{
    // Merge bundled and user sounds
    QList<SoundInfo> allRings = ringList + userRings;
    QList<SoundInfo> allVoices = voiceList + userVoices;
    QList<SoundInfo> allCompletes = completeList + userCompletes;
    
    // Get the layouts from the scroll area widgets
    QVBoxLayout *ringLayout = qobject_cast<QVBoxLayout*>(ui->ringScrollAreaContents->layout());
    QVBoxLayout *voiceLayout = qobject_cast<QVBoxLayout*>(ui->voiceScrollAreaContents->layout());
    QVBoxLayout *completeLayout = qobject_cast<QVBoxLayout*>(ui->completeScrollAreaContents->layout());

    if (ringLayout) createSoundCheckboxList(ringLayout, allRings, ringCheckboxes);
    if (voiceLayout) createSoundCheckboxList(voiceLayout, allVoices, voiceCheckboxes);
    if (completeLayout) createSoundCheckboxList(completeLayout, allCompletes, completeCheckboxes);
}

void SettingsDialog::loadUserSounds()
{
    QSettings settings("YourCompany", "HurrieUp");
    
    // Load user rings
    int ringCount = settings.beginReadArray("userRings");
    for (int i = 0; i < ringCount; ++i) {
        settings.setArrayIndex(i);
        SoundInfo sound;
        sound.name = settings.value("name").toString();
        sound.description = settings.value("description").toString();
        sound.path = settings.value("path").toString();
        sound.author = settings.value("author").toString();
        sound.license = settings.value("license").toString();
        sound.isBundled = false;
        
        // Check if file still exists
        if (QFile::exists(sound.path)) {
            userRings.append(sound);
        } else {
            qWarning() << "User sound file not found:" << sound.path;
        }
    }
    settings.endArray();
    
    // Load user voices
    int voiceCount = settings.beginReadArray("userVoices");
    for (int i = 0; i < voiceCount; ++i) {
        settings.setArrayIndex(i);
        SoundInfo sound;
        sound.name = settings.value("name").toString();
        sound.description = settings.value("description").toString();
        sound.path = settings.value("path").toString();
        sound.author = settings.value("author").toString();
        sound.license = settings.value("license").toString();
        sound.isBundled = false;
        
        if (QFile::exists(sound.path)) {
            userVoices.append(sound);
        } else {
            qWarning() << "User sound file not found:" << sound.path;
        }
    }
    settings.endArray();
    
    // Load user completes
    int completeCount = settings.beginReadArray("userCompletes");
    for (int i = 0; i < completeCount; ++i) {
        settings.setArrayIndex(i);
        SoundInfo sound;
        sound.name = settings.value("name").toString();
        sound.description = settings.value("description").toString();
        sound.path = settings.value("path").toString();
        sound.author = settings.value("author").toString();
        sound.license = settings.value("license").toString();
        sound.isBundled = false;
        
        if (QFile::exists(sound.path)) {
            userCompletes.append(sound);
        } else {
            qWarning() << "User sound file not found:" << sound.path;
        }
    }
    settings.endArray();
    
    qDebug() << "Loaded user sounds - Rings:" << userRings.size() 
             << "Voices:" << userVoices.size() 
             << "Completes:" << userCompletes.size();
}

void SettingsDialog::saveUserSounds()
{
    QSettings settings("YourCompany", "HurrieUp");
    
    // Save user rings
    settings.beginWriteArray("userRings");
    for (int i = 0; i < userRings.size(); ++i) {
        settings.setArrayIndex(i);
        settings.setValue("name", userRings[i].name);
        settings.setValue("description", userRings[i].description);
        settings.setValue("path", userRings[i].path);
        settings.setValue("author", userRings[i].author);
        settings.setValue("license", userRings[i].license);
    }
    settings.endArray();
    
    // Save user voices
    settings.beginWriteArray("userVoices");
    for (int i = 0; i < userVoices.size(); ++i) {
        settings.setArrayIndex(i);
        settings.setValue("name", userVoices[i].name);
        settings.setValue("description", userVoices[i].description);
        settings.setValue("path", userVoices[i].path);
        settings.setValue("author", userVoices[i].author);
        settings.setValue("license", userVoices[i].license);
    }
    settings.endArray();
    
    // Save user completes
    settings.beginWriteArray("userCompletes");
    for (int i = 0; i < userCompletes.size(); ++i) {
        settings.setArrayIndex(i);
        settings.setValue("name", userCompletes[i].name);
        settings.setValue("description", userCompletes[i].description);
        settings.setValue("path", userCompletes[i].path);
        settings.setValue("author", userCompletes[i].author);
        settings.setValue("license", userCompletes[i].license);
    }
    settings.endArray();
    
    qDebug() << "Saved user sounds - Rings:" << userRings.size() 
             << "Voices:" << userVoices.size() 
             << "Completes:" << userCompletes.size();
}

void SettingsDialog::showSoundInfo(const SoundInfo &sound)
{
    SoundInfoDialog dialog(sound, this);
    dialog.exec();
}
